{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"KeyBERT \u00b6 KeyBERT is a minimal and easy-to-use keyword extraction technique that leverages BERT embeddings to create keywords and keyphrases that are most similar to a document. About the Project \u00b6 Although there are already many methods available for keyword generation (e.g., Rake , YAKE! , TF-IDF, etc.) I wanted to create a very basic, but powerful method for extracting keywords and keyphrases. This is where KeyBERT comes in! Which uses BERT-embeddings and simple cosine similarity to find the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. KeyBERT is by no means unique and is created as a quick and easy method for creating keywords and keyphrases. Although there are many great papers and solutions out there that use BERT-embeddings (e.g., 1 , 2 , 3 , ), I could not find a BERT-based solution that did not have to be trained from scratch and could be used for beginners ( correct me if I'm wrong! ). Thus, the goal was a pip install keybert and at most 3 lines of code in usage. Installation \u00b6 Installation can be done using pypi : pip install keybert You may want to install more depending on the transformers and language backends that you will be using. The possible installations are: pip install keybert[flair] pip install keybert[gensim] pip install keybert[spacy] pip install keybert[use] To install all backends: pip install keybert[all] Usage \u00b6 The most minimal example can be seen below for the extraction of keywords: from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs. It infers a function from labeled training data consisting of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc ) You can set keyphrase_ngram_range to set the length of the resulting keywords/keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 1 ), stop_words = None ) [( 'learning' , 0.4604 ), ( 'algorithm' , 0.4556 ), ( 'training' , 0.4487 ), ( 'class' , 0.4086 ), ( 'mapping' , 0.3700 )] To extract keyphrases, simply set keyphrase_ngram_range to (1, 2) or higher depending on the number of words you would like in the resulting keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 2 ), stop_words = None ) [( 'learning algorithm' , 0.6978 ), ( 'machine learning' , 0.6305 ), ( 'supervised learning' , 0.5985 ), ( 'algorithm analyzes' , 0.5860 ), ( 'learning function' , 0.5850 )]","title":"Home"},{"location":"index.html#keybert","text":"KeyBERT is a minimal and easy-to-use keyword extraction technique that leverages BERT embeddings to create keywords and keyphrases that are most similar to a document.","title":"KeyBERT"},{"location":"index.html#about-the-project","text":"Although there are already many methods available for keyword generation (e.g., Rake , YAKE! , TF-IDF, etc.) I wanted to create a very basic, but powerful method for extracting keywords and keyphrases. This is where KeyBERT comes in! Which uses BERT-embeddings and simple cosine similarity to find the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. KeyBERT is by no means unique and is created as a quick and easy method for creating keywords and keyphrases. Although there are many great papers and solutions out there that use BERT-embeddings (e.g., 1 , 2 , 3 , ), I could not find a BERT-based solution that did not have to be trained from scratch and could be used for beginners ( correct me if I'm wrong! ). Thus, the goal was a pip install keybert and at most 3 lines of code in usage.","title":"About the Project"},{"location":"index.html#installation","text":"Installation can be done using pypi : pip install keybert You may want to install more depending on the transformers and language backends that you will be using. The possible installations are: pip install keybert[flair] pip install keybert[gensim] pip install keybert[spacy] pip install keybert[use] To install all backends: pip install keybert[all]","title":"Installation"},{"location":"index.html#usage","text":"The most minimal example can be seen below for the extraction of keywords: from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs. It infers a function from labeled training data consisting of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc ) You can set keyphrase_ngram_range to set the length of the resulting keywords/keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 1 ), stop_words = None ) [( 'learning' , 0.4604 ), ( 'algorithm' , 0.4556 ), ( 'training' , 0.4487 ), ( 'class' , 0.4086 ), ( 'mapping' , 0.3700 )] To extract keyphrases, simply set keyphrase_ngram_range to (1, 2) or higher depending on the number of words you would like in the resulting keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 2 ), stop_words = None ) [( 'learning algorithm' , 0.6978 ), ( 'machine learning' , 0.6305 ), ( 'supervised learning' , 0.5985 ), ( 'algorithm analyzes' , 0.5860 ), ( 'learning function' , 0.5850 )]","title":"Usage"},{"location":"changelog.html","text":"Version 0.5.0 \u00b6 Release date: 28 September, 2021 Highlights : Added Guided KeyBERT kw_model.extract_keywords(doc, seed_keywords=seed_keywords) Thanks to @zolekode for the inspiration! Use the newest all-* models from SBERT Miscellaneous : Added instructions in the FAQ to extract keywords from Chinese documents Version 0.4.0 \u00b6 Release date: 23 June, 2021 Highlights : Highlight a document's keywords with: keywords = kw_model.extract_keywords(doc, highlight=True) Use paraphrase-MiniLM-L6-v2 as the default embedder which gives great results! Miscellaneous : Update Flair dependencies Added FAQ Version 0.3.0 \u00b6 Release date: 10 May, 2021 The two main features are candidate keywords and several backends to use instead of Flair and SentenceTransformers! Highlights : Use candidate words instead of extracting those from the documents ( #25 ) KeyBERT().extract_keywords(doc, candidates) Spacy, Gensim, USE, and Custom Backends were added (see documentation here ) Fixes : Improved imports Fix encoding error when locally installing KeyBERT ( #30 ) Miscellaneous : Improved documentation (ReadMe & MKDocs) Add the main tutorial as a shield Typos ( #31 , #35 ) Version 0.2.0 \u00b6 Release date: 9 Feb, 2021 Highlights : Add similarity scores to the output Add Flair as a possible back-end Update documentation + improved testing * Version 0.1.2 \u00b6 Release date: 28 Oct, 2020 Added Max Sum Similarity as an option to diversify your results. Version 0.1.0 \u00b6 Release date: 27 Oct, 2020 This first release includes keyword/keyphrase extraction using BERT and simple cosine similarity. There is also an option to use Maximal Marginal Relevance to select the candidate keywords/keyphrases.","title":"Changelog"},{"location":"changelog.html#version-050","text":"Release date: 28 September, 2021 Highlights : Added Guided KeyBERT kw_model.extract_keywords(doc, seed_keywords=seed_keywords) Thanks to @zolekode for the inspiration! Use the newest all-* models from SBERT Miscellaneous : Added instructions in the FAQ to extract keywords from Chinese documents","title":"Version 0.5.0"},{"location":"changelog.html#version-040","text":"Release date: 23 June, 2021 Highlights : Highlight a document's keywords with: keywords = kw_model.extract_keywords(doc, highlight=True) Use paraphrase-MiniLM-L6-v2 as the default embedder which gives great results! Miscellaneous : Update Flair dependencies Added FAQ","title":"Version 0.4.0"},{"location":"changelog.html#version-030","text":"Release date: 10 May, 2021 The two main features are candidate keywords and several backends to use instead of Flair and SentenceTransformers! Highlights : Use candidate words instead of extracting those from the documents ( #25 ) KeyBERT().extract_keywords(doc, candidates) Spacy, Gensim, USE, and Custom Backends were added (see documentation here ) Fixes : Improved imports Fix encoding error when locally installing KeyBERT ( #30 ) Miscellaneous : Improved documentation (ReadMe & MKDocs) Add the main tutorial as a shield Typos ( #31 , #35 )","title":"Version 0.3.0"},{"location":"changelog.html#version-020","text":"Release date: 9 Feb, 2021 Highlights : Add similarity scores to the output Add Flair as a possible back-end Update documentation + improved testing","title":"Version 0.2.0"},{"location":"changelog.html#version-012","text":"Release date: 28 Oct, 2020 Added Max Sum Similarity as an option to diversify your results.","title":"*Version 0.1.2"},{"location":"changelog.html#version-010","text":"Release date: 27 Oct, 2020 This first release includes keyword/keyphrase extraction using BERT and simple cosine similarity. There is also an option to use Maximal Marginal Relevance to select the candidate keywords/keyphrases.","title":"Version 0.1.0"},{"location":"faq.html","text":"Which embedding model works best for which language? \u00b6 Unfortunately, there is not a definitive list of the best models for each language, this highly depends on your data, the model, and your specific use-case. However, the default model in KeyBERT ( \"all-MiniLM-L6-v2\" ) works great for English documents. In contrast, for multi-lingual documents or any other language, \"paraphrase-multilingual-MiniLM-L12-v2\"\" has shown great performance. If you want to use a model that provides a higher quality, but takes more compute time, then I would advise using paraphrase-mpnet-base-v2 and paraphrase-multilingual-mpnet-base-v2 instead. Should I preprocess the data? \u00b6 No. By using document embeddings there is typically no need to preprocess the data as all parts of a document are important in understanding the general topic of the document. Although this holds true in 99% of cases, if you have data that contains a lot of noise, for example, HTML-tags, then it would be best to remove them. HTML-tags typically do not contribute to the meaning of a document and should therefore be removed. However, if you apply topic modeling to HTML-code to extract topics of code, then it becomes important. Can I use the GPU to speed up the model? \u00b6 Yes! Since KeyBERT uses embeddings as its backend, a GPU is actually prefered when using this package. Although it is possible to use it without a dedicated GPU, the inference speed will be significantly slower. How can I use KeyBERT with Chinese documents? \u00b6 You need to make sure you use a Tokenizer in KeyBERT that supports tokenization of Chinese. I suggest installing jieba for this: from sklearn.feature_extraction.text import CountVectorizer import jieba def tokenize_zh ( text ): words = jieba . lcut ( text ) return words vectorizer = CountVectorizer ( tokenizer = tokenize_zh ) Then, simply pass the vectorizer to your KeyBERT instance: from keybert import KeyBERT kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc , vectorizer = vectorizer )","title":"FAQ"},{"location":"faq.html#which-embedding-model-works-best-for-which-language","text":"Unfortunately, there is not a definitive list of the best models for each language, this highly depends on your data, the model, and your specific use-case. However, the default model in KeyBERT ( \"all-MiniLM-L6-v2\" ) works great for English documents. In contrast, for multi-lingual documents or any other language, \"paraphrase-multilingual-MiniLM-L12-v2\"\" has shown great performance. If you want to use a model that provides a higher quality, but takes more compute time, then I would advise using paraphrase-mpnet-base-v2 and paraphrase-multilingual-mpnet-base-v2 instead.","title":"Which embedding model works best for which language?"},{"location":"faq.html#should-i-preprocess-the-data","text":"No. By using document embeddings there is typically no need to preprocess the data as all parts of a document are important in understanding the general topic of the document. Although this holds true in 99% of cases, if you have data that contains a lot of noise, for example, HTML-tags, then it would be best to remove them. HTML-tags typically do not contribute to the meaning of a document and should therefore be removed. However, if you apply topic modeling to HTML-code to extract topics of code, then it becomes important.","title":"Should I preprocess the data?"},{"location":"faq.html#can-i-use-the-gpu-to-speed-up-the-model","text":"Yes! Since KeyBERT uses embeddings as its backend, a GPU is actually prefered when using this package. Although it is possible to use it without a dedicated GPU, the inference speed will be significantly slower.","title":"Can I use the GPU to speed up the model?"},{"location":"faq.html#how-can-i-use-keybert-with-chinese-documents","text":"You need to make sure you use a Tokenizer in KeyBERT that supports tokenization of Chinese. I suggest installing jieba for this: from sklearn.feature_extraction.text import CountVectorizer import jieba def tokenize_zh ( text ): words = jieba . lcut ( text ) return words vectorizer = CountVectorizer ( tokenizer = tokenize_zh ) Then, simply pass the vectorizer to your KeyBERT instance: from keybert import KeyBERT kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc , vectorizer = vectorizer )","title":"How can I use KeyBERT with Chinese documents?"},{"location":"api/keybert.html","text":"KeyBERT \u00b6 A minimal method for keyword extraction with BERT The keyword extraction is done by finding the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. __init__ ( self , model = 'all-MiniLM-L6-v2' ) special \u00b6 KeyBERT initialization Parameters: Name Type Description Default model Use a custom embedding model. The following backends are currently supported * SentenceTransformers * Flair * Spacy * Gensim * USE (TF-Hub) You can also pass in a string that points to one of the following sentence-transformers models: * https://www.sbert.net/docs/pretrained_models.html 'all-MiniLM-L6-v2' Source code in keybert\\_model.py def __init__ ( self , model = \"all-MiniLM-L6-v2\" ): \"\"\" KeyBERT initialization Arguments: model: Use a custom embedding model. The following backends are currently supported * SentenceTransformers * Flair * Spacy * Gensim * USE (TF-Hub) You can also pass in a string that points to one of the following sentence-transformers models: * https://www.sbert.net/docs/pretrained_models.html \"\"\" self . model = select_backend ( model ) extract_keywords ( self , docs , candidates = None , keyphrase_ngram_range = ( 1 , 1 ), stop_words = 'english' , top_n = 5 , min_df = 1 , use_maxsum = False , use_mmr = False , diversity = 0.5 , nr_candidates = 20 , vectorizer = None , highlight = False , seed_keywords = None ) \u00b6 Extract keywords/keyphrases !!! note I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Parameters: Name Type Description Default docs Union[str, List[str]] The document(s) for which to extract keywords/keyphrases required candidates List[str] Candidate keywords/keyphrases to use instead of extracting them from the document(s) None keyphrase_ngram_range Tuple[int, int] Length, in words, of the extracted keywords/keyphrases (1, 1) stop_words Union[str, List[str]] Stopwords to remove from the document 'english' top_n int Return the top n keywords/keyphrases 5 min_df int Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted 1 use_maxsum bool Whether to use Max Sum Similarity for the selection of keywords/keyphrases False use_mmr bool Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases False diversity float The diversity of the results between 0 and 1 if use_mmr is set to True 0.5 nr_candidates int The number of candidates to consider if use_maxsum is set to True 20 vectorizer CountVectorizer Pass in your own CountVectorizer from scikit-learn None highlight bool Whether to print the document and highlight its keywords/keyphrases. NOTE: This does not work if multiple documents are passed. False seed_keywords List[str] Seed keywords that may guide the extraction of keywords by steering the similarities towards the seeded keywords None Returns: Type Description Union[List[Tuple[str, float]], List[List[Tuple[str, float]]]] keywords: the top n keywords for a document with their respective distances to the input document Source code in keybert\\_model.py def extract_keywords ( self , docs : Union [ str , List [ str ]], candidates : List [ str ] = None , keyphrase_ngram_range : Tuple [ int , int ] = ( 1 , 1 ), stop_words : Union [ str , List [ str ]] = 'english' , top_n : int = 5 , min_df : int = 1 , use_maxsum : bool = False , use_mmr : bool = False , diversity : float = 0.5 , nr_candidates : int = 20 , vectorizer : CountVectorizer = None , highlight : bool = False , seed_keywords : List [ str ] = None ) -> Union [ List [ Tuple [ str , float ]], List [ List [ Tuple [ str , float ]]]]: \"\"\" Extract keywords/keyphrases NOTE: I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Arguments: docs: The document(s) for which to extract keywords/keyphrases candidates: Candidate keywords/keyphrases to use instead of extracting them from the document(s) keyphrase_ngram_range: Length, in words, of the extracted keywords/keyphrases stop_words: Stopwords to remove from the document top_n: Return the top n keywords/keyphrases min_df: Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted use_maxsum: Whether to use Max Sum Similarity for the selection of keywords/keyphrases use_mmr: Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases diversity: The diversity of the results between 0 and 1 if use_mmr is set to True nr_candidates: The number of candidates to consider if use_maxsum is set to True vectorizer: Pass in your own CountVectorizer from scikit-learn highlight: Whether to print the document and highlight its keywords/keyphrases. NOTE: This does not work if multiple documents are passed. seed_keywords: Seed keywords that may guide the extraction of keywords by steering the similarities towards the seeded keywords Returns: keywords: the top n keywords for a document with their respective distances to the input document \"\"\" if isinstance ( docs , str ): keywords = self . _extract_keywords_single_doc ( doc = docs , candidates = candidates , keyphrase_ngram_range = keyphrase_ngram_range , stop_words = stop_words , top_n = top_n , use_maxsum = use_maxsum , use_mmr = use_mmr , diversity = diversity , nr_candidates = nr_candidates , vectorizer = vectorizer , seed_keywords = seed_keywords ) if highlight : highlight_document ( docs , keywords ) return keywords elif isinstance ( docs , list ): warnings . warn ( \"Although extracting keywords for multiple documents is faster \" \"than iterating over single documents, it requires significantly more memory \" \"to hold all word embeddings. Use this at your own discretion!\" ) return self . _extract_keywords_multiple_docs ( docs , keyphrase_ngram_range , stop_words , top_n , min_df , vectorizer )","title":"KeyBERT"},{"location":"api/keybert.html#keybert","text":"A minimal method for keyword extraction with BERT The keyword extraction is done by finding the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document.","title":"KeyBERT"},{"location":"api/keybert.html#keybert._model.KeyBERT.__init__","text":"KeyBERT initialization Parameters: Name Type Description Default model Use a custom embedding model. The following backends are currently supported * SentenceTransformers * Flair * Spacy * Gensim * USE (TF-Hub) You can also pass in a string that points to one of the following sentence-transformers models: * https://www.sbert.net/docs/pretrained_models.html 'all-MiniLM-L6-v2' Source code in keybert\\_model.py def __init__ ( self , model = \"all-MiniLM-L6-v2\" ): \"\"\" KeyBERT initialization Arguments: model: Use a custom embedding model. The following backends are currently supported * SentenceTransformers * Flair * Spacy * Gensim * USE (TF-Hub) You can also pass in a string that points to one of the following sentence-transformers models: * https://www.sbert.net/docs/pretrained_models.html \"\"\" self . model = select_backend ( model )","title":"__init__()"},{"location":"api/keybert.html#keybert._model.KeyBERT.extract_keywords","text":"Extract keywords/keyphrases !!! note I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Parameters: Name Type Description Default docs Union[str, List[str]] The document(s) for which to extract keywords/keyphrases required candidates List[str] Candidate keywords/keyphrases to use instead of extracting them from the document(s) None keyphrase_ngram_range Tuple[int, int] Length, in words, of the extracted keywords/keyphrases (1, 1) stop_words Union[str, List[str]] Stopwords to remove from the document 'english' top_n int Return the top n keywords/keyphrases 5 min_df int Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted 1 use_maxsum bool Whether to use Max Sum Similarity for the selection of keywords/keyphrases False use_mmr bool Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases False diversity float The diversity of the results between 0 and 1 if use_mmr is set to True 0.5 nr_candidates int The number of candidates to consider if use_maxsum is set to True 20 vectorizer CountVectorizer Pass in your own CountVectorizer from scikit-learn None highlight bool Whether to print the document and highlight its keywords/keyphrases. NOTE: This does not work if multiple documents are passed. False seed_keywords List[str] Seed keywords that may guide the extraction of keywords by steering the similarities towards the seeded keywords None Returns: Type Description Union[List[Tuple[str, float]], List[List[Tuple[str, float]]]] keywords: the top n keywords for a document with their respective distances to the input document Source code in keybert\\_model.py def extract_keywords ( self , docs : Union [ str , List [ str ]], candidates : List [ str ] = None , keyphrase_ngram_range : Tuple [ int , int ] = ( 1 , 1 ), stop_words : Union [ str , List [ str ]] = 'english' , top_n : int = 5 , min_df : int = 1 , use_maxsum : bool = False , use_mmr : bool = False , diversity : float = 0.5 , nr_candidates : int = 20 , vectorizer : CountVectorizer = None , highlight : bool = False , seed_keywords : List [ str ] = None ) -> Union [ List [ Tuple [ str , float ]], List [ List [ Tuple [ str , float ]]]]: \"\"\" Extract keywords/keyphrases NOTE: I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Arguments: docs: The document(s) for which to extract keywords/keyphrases candidates: Candidate keywords/keyphrases to use instead of extracting them from the document(s) keyphrase_ngram_range: Length, in words, of the extracted keywords/keyphrases stop_words: Stopwords to remove from the document top_n: Return the top n keywords/keyphrases min_df: Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted use_maxsum: Whether to use Max Sum Similarity for the selection of keywords/keyphrases use_mmr: Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases diversity: The diversity of the results between 0 and 1 if use_mmr is set to True nr_candidates: The number of candidates to consider if use_maxsum is set to True vectorizer: Pass in your own CountVectorizer from scikit-learn highlight: Whether to print the document and highlight its keywords/keyphrases. NOTE: This does not work if multiple documents are passed. seed_keywords: Seed keywords that may guide the extraction of keywords by steering the similarities towards the seeded keywords Returns: keywords: the top n keywords for a document with their respective distances to the input document \"\"\" if isinstance ( docs , str ): keywords = self . _extract_keywords_single_doc ( doc = docs , candidates = candidates , keyphrase_ngram_range = keyphrase_ngram_range , stop_words = stop_words , top_n = top_n , use_maxsum = use_maxsum , use_mmr = use_mmr , diversity = diversity , nr_candidates = nr_candidates , vectorizer = vectorizer , seed_keywords = seed_keywords ) if highlight : highlight_document ( docs , keywords ) return keywords elif isinstance ( docs , list ): warnings . warn ( \"Although extracting keywords for multiple documents is faster \" \"than iterating over single documents, it requires significantly more memory \" \"to hold all word embeddings. Use this at your own discretion!\" ) return self . _extract_keywords_multiple_docs ( docs , keyphrase_ngram_range , stop_words , top_n , min_df , vectorizer )","title":"extract_keywords()"},{"location":"api/maxsum.html","text":"Max Sum Similarity \u00b6 Calculate Max Sum Distance for extraction of keywords We take the 2 x top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 x top_n words and extract the combination that are the least similar to each other by cosine similarity. !!! note This is O(n^2) and therefore not advised if you use a large top_n Parameters: Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return required nr_candidates int The number of candidates to consider required Returns: Type Description List[Tuple[str, float]] List[Tuple[str, float]]: The selected keywords/keyphrases with their distances Source code in keybert\\_maxsum.py def max_sum_similarity ( doc_embedding : np . ndarray , word_embeddings : np . ndarray , words : List [ str ], top_n : int , nr_candidates : int ) -> List [ Tuple [ str , float ]]: \"\"\" Calculate Max Sum Distance for extraction of keywords We take the 2 x top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 x top_n words and extract the combination that are the least similar to each other by cosine similarity. NOTE: This is O(n^2) and therefore not advised if you use a large top_n Arguments: doc_embedding: The document embeddings word_embeddings: The embeddings of the selected candidate keywords/phrases words: The selected candidate keywords/keyphrases top_n: The number of keywords/keyhprases to return nr_candidates: The number of candidates to consider Returns: List[Tuple[str, float]]: The selected keywords/keyphrases with their distances \"\"\" if nr_candidates < top_n : raise Exception ( \"Make sure that the number of candidates exceeds the number \" \"of keywords to return.\" ) # Calculate distances and extract keywords distances = cosine_similarity ( doc_embedding , word_embeddings ) distances_words = cosine_similarity ( word_embeddings , word_embeddings ) # Get 2*top_n words as candidates based on cosine similarity words_idx = list ( distances . argsort ()[ 0 ][ - nr_candidates :]) words_vals = [ words [ index ] for index in words_idx ] candidates = distances_words [ np . ix_ ( words_idx , words_idx )] # Calculate the combination of words that are the least similar to each other min_sim = 100_000 candidate = None for combination in itertools . combinations ( range ( len ( words_idx )), top_n ): sim = sum ([ candidates [ i ][ j ] for i in combination for j in combination if i != j ]) if sim < min_sim : candidate = combination min_sim = sim return [( words_vals [ idx ], round ( float ( distances [ 0 ][ idx ]), 4 )) for idx in candidate ]","title":"MaxSum"},{"location":"api/maxsum.html#max-sum-similarity","text":"Calculate Max Sum Distance for extraction of keywords We take the 2 x top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 x top_n words and extract the combination that are the least similar to each other by cosine similarity. !!! note This is O(n^2) and therefore not advised if you use a large top_n Parameters: Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return required nr_candidates int The number of candidates to consider required Returns: Type Description List[Tuple[str, float]] List[Tuple[str, float]]: The selected keywords/keyphrases with their distances Source code in keybert\\_maxsum.py def max_sum_similarity ( doc_embedding : np . ndarray , word_embeddings : np . ndarray , words : List [ str ], top_n : int , nr_candidates : int ) -> List [ Tuple [ str , float ]]: \"\"\" Calculate Max Sum Distance for extraction of keywords We take the 2 x top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 x top_n words and extract the combination that are the least similar to each other by cosine similarity. NOTE: This is O(n^2) and therefore not advised if you use a large top_n Arguments: doc_embedding: The document embeddings word_embeddings: The embeddings of the selected candidate keywords/phrases words: The selected candidate keywords/keyphrases top_n: The number of keywords/keyhprases to return nr_candidates: The number of candidates to consider Returns: List[Tuple[str, float]]: The selected keywords/keyphrases with their distances \"\"\" if nr_candidates < top_n : raise Exception ( \"Make sure that the number of candidates exceeds the number \" \"of keywords to return.\" ) # Calculate distances and extract keywords distances = cosine_similarity ( doc_embedding , word_embeddings ) distances_words = cosine_similarity ( word_embeddings , word_embeddings ) # Get 2*top_n words as candidates based on cosine similarity words_idx = list ( distances . argsort ()[ 0 ][ - nr_candidates :]) words_vals = [ words [ index ] for index in words_idx ] candidates = distances_words [ np . ix_ ( words_idx , words_idx )] # Calculate the combination of words that are the least similar to each other min_sim = 100_000 candidate = None for combination in itertools . combinations ( range ( len ( words_idx )), top_n ): sim = sum ([ candidates [ i ][ j ] for i in combination for j in combination if i != j ]) if sim < min_sim : candidate = combination min_sim = sim return [( words_vals [ idx ], round ( float ( distances [ 0 ][ idx ]), 4 )) for idx in candidate ]","title":"Max Sum Similarity"},{"location":"api/mmr.html","text":"Maximal Marginal Relevance \u00b6 Calculate Maximal Marginal Relevance (MMR) between candidate keywords and the document. MMR considers the similarity of keywords/keyphrases with the document, along with the similarity of already selected keywords and keyphrases. This results in a selection of keywords that maximize their within diversity with respect to the document. Parameters: Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return 5 diversity float How diverse the select keywords/keyphrases are. Values between 0 and 1 with 0 being not diverse at all and 1 being most diverse. 0.8 Returns: Type Description List[Tuple[str, float]] List[Tuple[str, float]]: The selected keywords/keyphrases with their distances Source code in keybert\\_mmr.py def mmr ( doc_embedding : np . ndarray , word_embeddings : np . ndarray , words : List [ str ], top_n : int = 5 , diversity : float = 0.8 ) -> List [ Tuple [ str , float ]]: \"\"\" Calculate Maximal Marginal Relevance (MMR) between candidate keywords and the document. MMR considers the similarity of keywords/keyphrases with the document, along with the similarity of already selected keywords and keyphrases. This results in a selection of keywords that maximize their within diversity with respect to the document. Arguments: doc_embedding: The document embeddings word_embeddings: The embeddings of the selected candidate keywords/phrases words: The selected candidate keywords/keyphrases top_n: The number of keywords/keyhprases to return diversity: How diverse the select keywords/keyphrases are. Values between 0 and 1 with 0 being not diverse at all and 1 being most diverse. Returns: List[Tuple[str, float]]: The selected keywords/keyphrases with their distances \"\"\" # Extract similarity within words, and between words and the document word_doc_similarity = cosine_similarity ( word_embeddings , doc_embedding ) word_similarity = cosine_similarity ( word_embeddings ) # Initialize candidates and already choose best keyword/keyphras keywords_idx = [ np . argmax ( word_doc_similarity )] candidates_idx = [ i for i in range ( len ( words )) if i != keywords_idx [ 0 ]] for _ in range ( top_n - 1 ): # Extract similarities within candidates and # between candidates and selected keywords/phrases candidate_similarities = word_doc_similarity [ candidates_idx , :] target_similarities = np . max ( word_similarity [ candidates_idx ][:, keywords_idx ], axis = 1 ) # Calculate MMR mmr = ( 1 - diversity ) * candidate_similarities - diversity * target_similarities . reshape ( - 1 , 1 ) mmr_idx = candidates_idx [ np . argmax ( mmr )] # Update keywords & candidates keywords_idx . append ( mmr_idx ) candidates_idx . remove ( mmr_idx ) return [( words [ idx ], round ( float ( word_doc_similarity . reshape ( 1 , - 1 )[ 0 ][ idx ]), 4 )) for idx in keywords_idx ]","title":"MMR"},{"location":"api/mmr.html#maximal-marginal-relevance","text":"Calculate Maximal Marginal Relevance (MMR) between candidate keywords and the document. MMR considers the similarity of keywords/keyphrases with the document, along with the similarity of already selected keywords and keyphrases. This results in a selection of keywords that maximize their within diversity with respect to the document. Parameters: Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return 5 diversity float How diverse the select keywords/keyphrases are. Values between 0 and 1 with 0 being not diverse at all and 1 being most diverse. 0.8 Returns: Type Description List[Tuple[str, float]] List[Tuple[str, float]]: The selected keywords/keyphrases with their distances Source code in keybert\\_mmr.py def mmr ( doc_embedding : np . ndarray , word_embeddings : np . ndarray , words : List [ str ], top_n : int = 5 , diversity : float = 0.8 ) -> List [ Tuple [ str , float ]]: \"\"\" Calculate Maximal Marginal Relevance (MMR) between candidate keywords and the document. MMR considers the similarity of keywords/keyphrases with the document, along with the similarity of already selected keywords and keyphrases. This results in a selection of keywords that maximize their within diversity with respect to the document. Arguments: doc_embedding: The document embeddings word_embeddings: The embeddings of the selected candidate keywords/phrases words: The selected candidate keywords/keyphrases top_n: The number of keywords/keyhprases to return diversity: How diverse the select keywords/keyphrases are. Values between 0 and 1 with 0 being not diverse at all and 1 being most diverse. Returns: List[Tuple[str, float]]: The selected keywords/keyphrases with their distances \"\"\" # Extract similarity within words, and between words and the document word_doc_similarity = cosine_similarity ( word_embeddings , doc_embedding ) word_similarity = cosine_similarity ( word_embeddings ) # Initialize candidates and already choose best keyword/keyphras keywords_idx = [ np . argmax ( word_doc_similarity )] candidates_idx = [ i for i in range ( len ( words )) if i != keywords_idx [ 0 ]] for _ in range ( top_n - 1 ): # Extract similarities within candidates and # between candidates and selected keywords/phrases candidate_similarities = word_doc_similarity [ candidates_idx , :] target_similarities = np . max ( word_similarity [ candidates_idx ][:, keywords_idx ], axis = 1 ) # Calculate MMR mmr = ( 1 - diversity ) * candidate_similarities - diversity * target_similarities . reshape ( - 1 , 1 ) mmr_idx = candidates_idx [ np . argmax ( mmr )] # Update keywords & candidates keywords_idx . append ( mmr_idx ) candidates_idx . remove ( mmr_idx ) return [( words [ idx ], round ( float ( word_doc_similarity . reshape ( 1 , - 1 )[ 0 ][ idx ]), 4 )) for idx in keywords_idx ]","title":"Maximal Marginal Relevance"},{"location":"guides/embeddings.html","text":"Embedding Models \u00b6 In this tutorial we will be going through the embedding models that can be used in KeyBERT. Having the option to choose embedding models allow you to leverage pre-trained embeddings that suit your use-case. Sentence Transformers \u00b6 You can select any model from sentence-transformers here and pass it through KeyBERT with model : from keybert import KeyBERT kw_model = KeyBERT ( model = \"all-MiniLM-L6-v2\" ) Or select a SentenceTransformer model with your own parameters: from sentence_transformers import SentenceTransformer sentence_model = SentenceTransformer ( \"all-MiniLM-L6-v2\" ) kw_model = KeyBERT ( model = sentence_model ) Flair \u00b6 Flair allows you to choose almost any embedding model that is publicly available. Flair can be used as follows: from flair.embeddings import TransformerDocumentEmbeddings roberta = TransformerDocumentEmbeddings ( 'roberta-base' ) kw_model = KeyBERT ( model = roberta ) You can select any \ud83e\udd17 transformers model here . Moreover, you can also use Flair to use word embeddings and pool them to create document embeddings. Under the hood, Flair simply averages all word embeddings in a document. Then, we can easily pass it to KeyBERT in order to use those word embeddings as document embeddings: from flair.embeddings import WordEmbeddings , DocumentPoolEmbeddings glove_embedding = WordEmbeddings ( 'crawl' ) document_glove_embeddings = DocumentPoolEmbeddings ([ glove_embedding ]) kw_model = KeyBERT ( model = document_glove_embeddings ) Spacy \u00b6 Spacy is an amazing framework for processing text. There are many models available across many languages for modeling text. allows you to choose almost any embedding model that is publicly available. Flair can be used as follows: To use Spacy's non-transformer models in KeyBERT: import spacy nlp = spacy . load ( \"en_core_web_md\" , exclude = [ 'tagger' , 'parser' , 'ner' , 'attribute_ruler' , 'lemmatizer' ]) kw_model = KeyBERT ( model = nlp ) Using spacy-transformer models: import spacy spacy . prefer_gpu () nlp = spacy . load ( \"en_core_web_trf\" , exclude = [ 'tagger' , 'parser' , 'ner' , 'attribute_ruler' , 'lemmatizer' ]) kw_model = KeyBERT ( model = nlp ) If you run into memory issues with spacy-transformer models, try: import spacy from thinc.api import set_gpu_allocator , require_gpu nlp = spacy . load ( \"en_core_web_trf\" , exclude = [ 'tagger' , 'parser' , 'ner' , 'attribute_ruler' , 'lemmatizer' ]) set_gpu_allocator ( \"pytorch\" ) require_gpu ( 0 ) kw_model = KeyBERT ( model = nlp ) Universal Sentence Encoder (USE) \u00b6 The Universal Sentence Encoder encodes text into high dimensional vectors that are used here for embedding the documents. The model is trained and optimized for greater-than-word length text, such as sentences, phrases or short paragraphs. Using USE in KeyBERT is rather straightforward: import tensorflow_hub embedding_model = tensorflow_hub . load ( \"https://tfhub.dev/google/universal-sentence-encoder/4\" ) kw_model = KeyBERT ( model = embedding_model ) Gensim \u00b6 For Gensim, KeyBERT supports its gensim.downloader module. Here, we can download any model word embedding model to be used in KeyBERT. Note that Gensim is primarily used for Word Embedding models. This works typically best for short documents since the word embeddings are pooled. import gensim.downloader as api ft = api . load ( 'fasttext-wiki-news-subwords-300' ) kw_model = KeyBERT ( model = ft ) Custom Backend \u00b6 If your backend or model cannot be found in the ones currently available, you can use the keybert.backend.BaseEmbedder class to create your own backend. Below, you will find an example of creating a SentenceTransformer backend for KeyBERT: from keybert.backend import BaseEmbedder from sentence_transformers import SentenceTransformer class CustomEmbedder ( BaseEmbedder ): def __init__ ( self , embedding_model ): super () . __init__ () self . embedding_model = embedding_model def embed ( self , documents , verbose = False ): embeddings = self . embedding_model . encode ( documents , show_progress_bar = verbose ) return embeddings # Create custom backend distilbert = SentenceTransformer ( \"paraphrase-MiniLM-L6-v2\" ) custom_embedder = CustomEmbedder ( embedding_model = distilbert ) # Pass custom backend to keybert kw_model = KeyBERT ( model = custom_embedder )","title":"Embedding Models"},{"location":"guides/embeddings.html#embedding-models","text":"In this tutorial we will be going through the embedding models that can be used in KeyBERT. Having the option to choose embedding models allow you to leverage pre-trained embeddings that suit your use-case.","title":"Embedding Models"},{"location":"guides/embeddings.html#sentence-transformers","text":"You can select any model from sentence-transformers here and pass it through KeyBERT with model : from keybert import KeyBERT kw_model = KeyBERT ( model = \"all-MiniLM-L6-v2\" ) Or select a SentenceTransformer model with your own parameters: from sentence_transformers import SentenceTransformer sentence_model = SentenceTransformer ( \"all-MiniLM-L6-v2\" ) kw_model = KeyBERT ( model = sentence_model )","title":"Sentence Transformers"},{"location":"guides/embeddings.html#flair","text":"Flair allows you to choose almost any embedding model that is publicly available. Flair can be used as follows: from flair.embeddings import TransformerDocumentEmbeddings roberta = TransformerDocumentEmbeddings ( 'roberta-base' ) kw_model = KeyBERT ( model = roberta ) You can select any \ud83e\udd17 transformers model here . Moreover, you can also use Flair to use word embeddings and pool them to create document embeddings. Under the hood, Flair simply averages all word embeddings in a document. Then, we can easily pass it to KeyBERT in order to use those word embeddings as document embeddings: from flair.embeddings import WordEmbeddings , DocumentPoolEmbeddings glove_embedding = WordEmbeddings ( 'crawl' ) document_glove_embeddings = DocumentPoolEmbeddings ([ glove_embedding ]) kw_model = KeyBERT ( model = document_glove_embeddings )","title":"Flair"},{"location":"guides/embeddings.html#spacy","text":"Spacy is an amazing framework for processing text. There are many models available across many languages for modeling text. allows you to choose almost any embedding model that is publicly available. Flair can be used as follows: To use Spacy's non-transformer models in KeyBERT: import spacy nlp = spacy . load ( \"en_core_web_md\" , exclude = [ 'tagger' , 'parser' , 'ner' , 'attribute_ruler' , 'lemmatizer' ]) kw_model = KeyBERT ( model = nlp ) Using spacy-transformer models: import spacy spacy . prefer_gpu () nlp = spacy . load ( \"en_core_web_trf\" , exclude = [ 'tagger' , 'parser' , 'ner' , 'attribute_ruler' , 'lemmatizer' ]) kw_model = KeyBERT ( model = nlp ) If you run into memory issues with spacy-transformer models, try: import spacy from thinc.api import set_gpu_allocator , require_gpu nlp = spacy . load ( \"en_core_web_trf\" , exclude = [ 'tagger' , 'parser' , 'ner' , 'attribute_ruler' , 'lemmatizer' ]) set_gpu_allocator ( \"pytorch\" ) require_gpu ( 0 ) kw_model = KeyBERT ( model = nlp )","title":"Spacy"},{"location":"guides/embeddings.html#universal-sentence-encoder-use","text":"The Universal Sentence Encoder encodes text into high dimensional vectors that are used here for embedding the documents. The model is trained and optimized for greater-than-word length text, such as sentences, phrases or short paragraphs. Using USE in KeyBERT is rather straightforward: import tensorflow_hub embedding_model = tensorflow_hub . load ( \"https://tfhub.dev/google/universal-sentence-encoder/4\" ) kw_model = KeyBERT ( model = embedding_model )","title":"Universal Sentence Encoder (USE)"},{"location":"guides/embeddings.html#gensim","text":"For Gensim, KeyBERT supports its gensim.downloader module. Here, we can download any model word embedding model to be used in KeyBERT. Note that Gensim is primarily used for Word Embedding models. This works typically best for short documents since the word embeddings are pooled. import gensim.downloader as api ft = api . load ( 'fasttext-wiki-news-subwords-300' ) kw_model = KeyBERT ( model = ft )","title":"Gensim"},{"location":"guides/embeddings.html#custom-backend","text":"If your backend or model cannot be found in the ones currently available, you can use the keybert.backend.BaseEmbedder class to create your own backend. Below, you will find an example of creating a SentenceTransformer backend for KeyBERT: from keybert.backend import BaseEmbedder from sentence_transformers import SentenceTransformer class CustomEmbedder ( BaseEmbedder ): def __init__ ( self , embedding_model ): super () . __init__ () self . embedding_model = embedding_model def embed ( self , documents , verbose = False ): embeddings = self . embedding_model . encode ( documents , show_progress_bar = verbose ) return embeddings # Create custom backend distilbert = SentenceTransformer ( \"paraphrase-MiniLM-L6-v2\" ) custom_embedder = CustomEmbedder ( embedding_model = distilbert ) # Pass custom backend to keybert kw_model = KeyBERT ( model = custom_embedder )","title":"Custom Backend"},{"location":"guides/quickstart.html","text":"Installation \u00b6 Installation can be done using pypi : pip install keybert You may want to install more depending on the transformers and language backends that you will be using. The possible installations are: pip install keybert[flair] pip install keybert[gensim] pip install keybert[spacy] pip install keybert[use] To install all backends: pip install keybert[all] Usage \u00b6 The most minimal example can be seen below for the extraction of keywords: from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc ) You can set keyphrase_ngram_range to set the length of the resulting keywords/keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 1 ), stop_words = None ) [( 'learning' , 0.4604 ), ( 'algorithm' , 0.4556 ), ( 'training' , 0.4487 ), ( 'class' , 0.4086 ), ( 'mapping' , 0.3700 )] To extract keyphrases, simply set keyphrase_ngram_range to (1, 2) or higher depending on the number of words you would like in the resulting keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 2 ), stop_words = None ) [( 'learning algorithm' , 0.6978 ), ( 'machine learning' , 0.6305 ), ( 'supervised learning' , 0.5985 ), ( 'algorithm analyzes' , 0.5860 ), ( 'learning function' , 0.5850 )] We can highlight the keywords in the document by simply setting hightlight : keywords = kw_model . extract_keywords ( doc , highlight = True ) NOTE : For a full overview of all possible transformer models see sentence-transformer . I would advise either \"all-MiniLM-L6-v2\" for English documents or \"paraphrase-multilingual-MiniLM-L12-v2\" for multi-lingual documents or any other language. Max Sum Similarity \u00b6 To diversify the results, we take the 2 x top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 x top_n words and extract the combination that are the least similar to each other by cosine similarity. >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 3 , 3 ), stop_words = 'english' , use_maxsum = True , nr_candidates = 20 , top_n = 5 ) [( 'set training examples' , 0.7504 ), ( 'generalize training data' , 0.7727 ), ( 'requires learning algorithm' , 0.5050 ), ( 'supervised learning algorithm' , 0.3779 ), ( 'learning machine learning' , 0.2891 )] Maximal Marginal Relevance \u00b6 To diversify the results, we can use Maximal Margin Relevance (MMR) to create keywords / keyphrases which is also based on cosine similarity. The results with high diversity : >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 3 , 3 ), stop_words = 'english' , use_mmr = True , diversity = 0.7 ) [( 'algorithm generalize training' , 0.7727 ), ( 'labels unseen instances' , 0.1649 ), ( 'new examples optimal' , 0.4185 ), ( 'determine class labels' , 0.4774 ), ( 'supervised learning algorithm' , 0.7502 )] The results with low diversity : >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 3 , 3 ), stop_words = 'english' , use_mmr = True , diversity = 0.2 ) [( 'algorithm generalize training' , 0.7727 ), ( 'supervised learning algorithm' , 0.7502 ), ( 'learning machine learning' , 0.7577 ), ( 'learning algorithm analyzes' , 0.7587 ), ( 'learning algorithm generalize' , 0.7514 )] Candidate Keywords/Keyphrases \u00b6 In some cases, one might want to be using candidate keywords generated by other keyword algorithms or retrieved from a select list of possible keywords/keyphrases. In KeyBERT, you can easily use those candidate keywords to perform keyword extraction: import yake from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" # Create candidates kw_extractor = yake . KeywordExtractor ( top = 50 ) candidates = kw_extractor . extract_keywords ( doc ) candidates = [ candidate [ 0 ] for candidate in candidates ] # KeyBERT init kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc , candidates ) Guided KeyBERT \u00b6 Guided KeyBERT is similar to Guided Topic Modeling in that it tries to steer the training towards a set of seeded terms. When applying KeyBERT it automatically extracts the most related keywords to a specific document. However, there are times when stakeholders and users are looking for specific types of keywords. For example, when publishing an article on your website through contentful, you typically already know the global keywords related to the article. However, there might be a specific topic in the article that you would like to be extracted through the keywords. To achieve this, we simply give KeyBERT a set of related seeded keywords (it can also be a single one!) and search for keywords that are similar to both the document and the seeded keywords. Using this feature is as simple as defining a list of seeded keywords and passing them to KeyBERT: doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" kw_model = KeyBERT () seed_keywords = [ \"information\" ] keywords = kw_model . extract_keywords ( doc , use_mmr = True , diversity = 0.1 , seed_keywords = seed_keywords )","title":"Quickstart"},{"location":"guides/quickstart.html#installation","text":"Installation can be done using pypi : pip install keybert You may want to install more depending on the transformers and language backends that you will be using. The possible installations are: pip install keybert[flair] pip install keybert[gensim] pip install keybert[spacy] pip install keybert[use] To install all backends: pip install keybert[all]","title":"Installation"},{"location":"guides/quickstart.html#usage","text":"The most minimal example can be seen below for the extraction of keywords: from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc ) You can set keyphrase_ngram_range to set the length of the resulting keywords/keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 1 ), stop_words = None ) [( 'learning' , 0.4604 ), ( 'algorithm' , 0.4556 ), ( 'training' , 0.4487 ), ( 'class' , 0.4086 ), ( 'mapping' , 0.3700 )] To extract keyphrases, simply set keyphrase_ngram_range to (1, 2) or higher depending on the number of words you would like in the resulting keyphrases: >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 1 , 2 ), stop_words = None ) [( 'learning algorithm' , 0.6978 ), ( 'machine learning' , 0.6305 ), ( 'supervised learning' , 0.5985 ), ( 'algorithm analyzes' , 0.5860 ), ( 'learning function' , 0.5850 )] We can highlight the keywords in the document by simply setting hightlight : keywords = kw_model . extract_keywords ( doc , highlight = True ) NOTE : For a full overview of all possible transformer models see sentence-transformer . I would advise either \"all-MiniLM-L6-v2\" for English documents or \"paraphrase-multilingual-MiniLM-L12-v2\" for multi-lingual documents or any other language.","title":"Usage"},{"location":"guides/quickstart.html#max-sum-similarity","text":"To diversify the results, we take the 2 x top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 x top_n words and extract the combination that are the least similar to each other by cosine similarity. >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 3 , 3 ), stop_words = 'english' , use_maxsum = True , nr_candidates = 20 , top_n = 5 ) [( 'set training examples' , 0.7504 ), ( 'generalize training data' , 0.7727 ), ( 'requires learning algorithm' , 0.5050 ), ( 'supervised learning algorithm' , 0.3779 ), ( 'learning machine learning' , 0.2891 )]","title":"Max Sum Similarity"},{"location":"guides/quickstart.html#maximal-marginal-relevance","text":"To diversify the results, we can use Maximal Margin Relevance (MMR) to create keywords / keyphrases which is also based on cosine similarity. The results with high diversity : >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 3 , 3 ), stop_words = 'english' , use_mmr = True , diversity = 0.7 ) [( 'algorithm generalize training' , 0.7727 ), ( 'labels unseen instances' , 0.1649 ), ( 'new examples optimal' , 0.4185 ), ( 'determine class labels' , 0.4774 ), ( 'supervised learning algorithm' , 0.7502 )] The results with low diversity : >>> kw_model . extract_keywords ( doc , keyphrase_ngram_range = ( 3 , 3 ), stop_words = 'english' , use_mmr = True , diversity = 0.2 ) [( 'algorithm generalize training' , 0.7727 ), ( 'supervised learning algorithm' , 0.7502 ), ( 'learning machine learning' , 0.7577 ), ( 'learning algorithm analyzes' , 0.7587 ), ( 'learning algorithm generalize' , 0.7514 )]","title":"Maximal Marginal Relevance"},{"location":"guides/quickstart.html#candidate-keywordskeyphrases","text":"In some cases, one might want to be using candidate keywords generated by other keyword algorithms or retrieved from a select list of possible keywords/keyphrases. In KeyBERT, you can easily use those candidate keywords to perform keyword extraction: import yake from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" # Create candidates kw_extractor = yake . KeywordExtractor ( top = 50 ) candidates = kw_extractor . extract_keywords ( doc ) candidates = [ candidate [ 0 ] for candidate in candidates ] # KeyBERT init kw_model = KeyBERT () keywords = kw_model . extract_keywords ( doc , candidates )","title":"Candidate Keywords/Keyphrases"},{"location":"guides/quickstart.html#guided-keybert","text":"Guided KeyBERT is similar to Guided Topic Modeling in that it tries to steer the training towards a set of seeded terms. When applying KeyBERT it automatically extracts the most related keywords to a specific document. However, there are times when stakeholders and users are looking for specific types of keywords. For example, when publishing an article on your website through contentful, you typically already know the global keywords related to the article. However, there might be a specific topic in the article that you would like to be extracted through the keywords. To achieve this, we simply give KeyBERT a set of related seeded keywords (it can also be a single one!) and search for keywords that are similar to both the document and the seeded keywords. Using this feature is as simple as defining a list of seeded keywords and passing them to KeyBERT: doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" kw_model = KeyBERT () seed_keywords = [ \"information\" ] keywords = kw_model . extract_keywords ( doc , use_mmr = True , diversity = 0.1 , seed_keywords = seed_keywords )","title":"Guided KeyBERT"}]}